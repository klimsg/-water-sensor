import serial
import datetime
import os
import csv
import pystray
import PIL.Image
import tkinter as tk
import telebot
import requests
import threading
from multiprocessing import Process
from queue import Queue
from threading import Thread

Token = '6660578623:AAGjC0Majly1L2-toXRTWzMwjhKK5ovJHug'
chat_id = "5143103884"
bot = telebot.TeleBot(Token)



Exit = False
V="0"
print(V,'glob')
# Участок с созданием папки
if not os.path.isdir("Показания"):
     os.mkdir("Показания")









def tester(out_q):
    # Участок кода Окно
    def window():
        def testimony():
            global V
            volume.config(text=V + " Литров")
            volume.after(1000, testimony)
            if (Exit == True):
                volume.after(2, testimony)
                win.quit()

        win = tk.Tk()
        win.title('Объем воды в колодце')
        win.geometry("400x100+500+500")
        win.tk.call("wm", "iconphoto", win._w, tk.PhotoImage(file="logo.png"))
        # resizable.Так
        win.resizable(False, False)

        volume = tk.Label(win, font='Calibri 50 bold', foreground='black')
        volume.pack(anchor='center')

        testimony()
        win.mainloop()

    # Участок кода с нажатием на список в трее
    def on_clicked(icon, item):
        if str(item) == 'Выход':
            global Exit
            Exit = True
            icon.stop()
        elif str(item) == 'Окно':
            window()
        elif str(item) == 'Телега':
            url = f"https://api.telegram.org/bot{Token}/sendMessage?chat_id={chat_id}&text=Всем привет"
            print(requests.get(url).json())
        return Exit

    # Иконка в трее картинка
    imagetree = PIL.Image.open('Logo.png')

    # Код иконки в трее
    icon = pystray.Icon('Serg', imagetree, menu=pystray.Menu(
        pystray.MenuItem('Телега', on_clicked),
        pystray.MenuItem('Окно', on_clicked),
        pystray.MenuItem('Выход', on_clicked)

    ))

    # Запуск иконки
    icon.run_detached()

    # Выключение
    if (Exit == True):
        icon.update(visible=False)
        exit()

    #Настройка конфигурации COM порта
    port = "COM4"  # Replace with the appropriate COM port name
    baudrate = 9600

    #Исключение ошибки COM порта
    try:
        # Open the COM port
        ser = serial.Serial(port, baudrate=baudrate)
        print("Порт подключен.")

        # Read data from the Arduino
        while True:
            # Read a line of data from the serial port
            line = ser.readline().decode().strip()

            if line:

                begin_char = line.find('Объём ')  # мы знаем, что список начинается с 'Объём '
                end_char = line.find(' Л')  # убираем 2 последних символов с конца
                global V
                V=line[begin_char+6:end_char]
                # Подготовка времени
                current_date_time = datetime.datetime.now()
                current_time = current_date_time.time().strftime("%H:%M:%S")

                # Работа с файлом
                current_datetime = datetime.datetime.now().strftime("%Y-%m-%d")
                # convert datetime obj to string
                str_current_datetime = str(current_datetime)

                # create a file object along with extension
                file_name = str_current_datetime + ".CSV"
                file_fold = "Показания/"+file_name

                file = open(file_fold, 'a')
                with open(file_fold, mode="a", encoding='utf-8') as w_file:
                    file = csv.writer(w_file, delimiter=";", lineterminator="\r")
                    file.writerow([current_time, V])

                print(line)
                out_q.put(V)

                # Отключение COM порта
                if (Exit == True):

                    ser.close()
                    print("Serial connection END SG.")






    except serial.SerialException as se:
        print("Serial port error:", str(se))

    except KeyboardInterrupt:
        pass

    finally:
        # Close the serial connection
        if ser.is_open:
            ser.close()
            print("Serial connection closed.")


# Участок телеграмм бота
def Mybot(in_q):

    @bot.message_handler(content_types=['text'])
    def get_text_messages(message):
        V = in_q.get()
        if (message.text == "Вода"):
            bot.send_message(message.from_user.id, text=V+" литров")
        elif message.text == "Привет":
            bot.send_message(message.from_user.id, text="Слушаю Вас. Мой Повелитель.")
        elif message.text == "/help":
            bot.send_message(message.from_user.id, "Напиши привет")
        else:
            bot.send_message(message.from_user.id, "Я тебя не понимаю. Напиши /help.")




    bot.polling(non_stop=True, none_stop=True, timeout=1)


if __name__ == '__main__':
    q = Queue()
#    p1 = Process(target=tester, args=(q, ), daemon=True)
#    p2 = Process(target=Mybot, args=(q, ), daemon=True)
    p1 = Thread(target=tester, args=(q, ))
    p2 = Thread(target=Mybot, args=(q, ))
    p1.start()
    p2.start()
    p1.join()
    p2.join()




